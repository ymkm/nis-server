{
  "name": "q-combinators",
  "version": "0.4.2",
  "description": "Functions to combine q promises, capturing lots of useful, real world patterns.",
  "main": "index.js",
  "dependencies": {
    "q": "1.0.0",
    "lodash": "2.4.1"
  },
  "scripts": {
    "test": "./node_modules/mocha/bin/mocha test/ --reporter spec"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/beamly/q-combinators"
  },
  "keywords": [
    "q",
    "promises",
    "combinators",
    "util",
    "utility",
    "promise",
    "combine"
  ],
  "author": {
    "name": "Beamly ltd."
  },
  "bugs": {
    "url": "https://github.com/beamly/q-combinators/issues"
  },
  "devDependencies": {
    "mocha": "1.17.0",
    "should": "3.0.1",
    "sinon": "1.7.3"
  },
  "readme": "# q-combinators\n\nFunctions to combine q promises, capturing lots of useful, real world patterns used across Beamly's node.js services.\n\n## Installing\n\n```bash\nnpm install q-combinators --save\n```\n\n## API\n\n### .object.all\n\nResolves an object of promises with an object of the resultant values if all promises resolve.  If any promise rejects, it rejects with the same reason\n\n```javascript\n// happy path\nqCombinators.object.all({\n\tx: Q('foo'),\n\ty: Q('bar'),\n\tz: Q('quux')\n})\n.then(function(object){\n\t// object is:\n\t// {\n\t//   x: 'foo',\n\t//   y: 'bar',\n\t//   z: 'quux'\n\t// }\n});\n\n// sad path\nqCombinators.object.all({\n\tx: Q.reject('foo'),\n\ty: Q(),\n\tz: Q()\n})\n.then(null, function(err){\n\t// err is 'foo'\n});\n```\n\n### .object.allSettled\n\nResolves an object of promises with *all* results, using the same format as Q.allSettled\n\n```javascript\nqCombinators.object.allSettled({\n\tx: Q.reject('foo'),\n\ty: Q('bar'),\n\tz: Q('quux')\n})\n.then(function(object){\n\t// object is:\n\t// {\n\t//\t  x: { state: 'rejected', reason: 'foo' },\n\t//\t  y: { state: 'fulfilled', value: 'bar' },\n\t//\t  z: { state: 'fulfilled', value: 'quux' }\n\t// }\n});\n```\n\n### .object.fulfilled\n\nResolves an object of promises with *only* the fulfilled values.  If none of the promises fulfill, it fulfills with an empty object.\n\n```javascript\nqCombinators.object.fulfilled({\n\tx: Q.reject('foo'),\n\ty: Q('bar'),\n\tz: Q('quux')\n})\n.then(function(object){\n\t// object is:\n\t// {\n\t//   y: 'bar',\n\t//   z: 'quux'\n\t// }\n});\n```\n\n### .object.rejected\n\nResolves an object of promises with *only* the rejected values.  If none of the promises are rejected, it fulfills with an empty object.\n\n```javascript\nqCombinators.object.rejected({\n\tx: Q.reject('foo'),\n\ty: Q('bar'),\n\tz: Q('quux')\n})\n.then(function(object){\n\t// object is:\n\t// {\n\t//   x: 'foo'\n\t// }\n});\n```\n\n\n### .object.demand\n\nResolves an object of promises when the 'demanded' keys contain successful promises.\n\nIf a demanded promise fails, the returned promise will also fail.\n\n\n```javascript\n// happy path\nqCombinators.object.demand({\n\tx: Q('foo'),\n\ty: Q.reject('bar'),\n\tz: Q('quux')\n})\n.then(function(object){\n\t// object is:\n\t// {\n\t//   x: 'foo',\n\t//   z: 'quux'\n\t// }\n});\n\n// sad path\ndemand(['x', 'y'], {\n\tx: Q.reject('foo'),\n\ty: Q('bar'),\n\tz: Q('quux')\n})\n.fail(function(errs){\n\t// errs is:\n\t// {\n\t//   x: 'foo'\n\t// }\n});\n```\n\n### .array.fulfilled\n\nResolves an array of promises with *only* the fulfilled values.  If none of the promises are fulfilled, it fulfills with an empty array.\n\n```javascript\nqCombinators.array.fulfilled([\n    Q.reject('foo'),\n    Q('bar'),\n    Q('quux')\n])\n.then(function(value){\n    // value is: ['bar', 'quux']\n});\n```\n\n### .array.rejected\n\nResolves an array of promises with *only* the rejected values.  If none of the promises are rejected, it fulfills with an empty array.\n\n```javascript\nqCombinators.array.rejected([\n    Q.reject('foo'),\n    Q.reject('bar'),\n    Q('quux')\n])\n.then(function(value){\n    // value is: ['foo', 'bar']\n});\n```\n\n### .chain\n\nSequentially executes an array of promise-returning functions.  The equivalent of a lot of `.then` chains:\n\n```javascript\nvar inc = function(a){ return a + 1 };\nvar promise1 = function(){ return Q(1) };\n\nqCombinators.chain([promise1, inc, inc, inc])\n\t.then(function(val){\n\t\t// val === 4\n\t});\n```\n\n### .fallback\n\nSequentially executes an array of functions which return promises, until the first promise is resolved. If all promises are rejected it itself is rejected with an array of all the failure reasons.\n\n```javascript\n// happy path\nqCombinators.fallback([\n\tfunction() { return Q.reject('foo'); },\n\tfunction() { return Q('bar'); },\n\tfunction() { return Q.reject('baz'); }\n])\n.then(function(result){\n\t// result is 'bar'\n});\n\n// sad path\nqCombinators.fallback([\n\tfunction() { return Q.reject('foo'); },\n\tfunction() { return Q.reject('bar'); },\n\tfunction() { return Q.reject('baz'); }\n])\n.fail(function(results) {\n\t// results is:\n\t// [\n\t//   'foo',\n\t//   'bar',\n\t//   'baz'\n\t// ]\n});\n```\n\n### .fallbackParallel\n\nSame as .fallback, but takes an array of promises, allowing fetching results in parallel, then accepting them in preferential order.\n\n```javascript\n// happy path\nqCombinators.fallbackParallel([\n\tQ.reject('foo'),\n\tQ('bar'),\n\tQ.reject('baz')\n])\n.then(function(result){\n\t// result is 'bar'\n});\n\n// sad path\nqCombinators.fallbackParallel([\n\tQ.reject('foo'),\n\tQ.reject('bar'),\n\tQ.reject('baz')\n])\n.fail(function(results) {\n\t// results is:\n\t// [\n\t//   'foo',\n\t//   'bar',\n\t//   'baz'\n\t// ]\n});\n```\n\n\n## Contributing\n\nContributions are currently not being accepted.\n\n## Licensing\n\nThis project is licensed under the [BSD 3-Clause license](http://opensource.org/licenses/BSD-3-Clause).\n",
  "readmeFilename": "README.markdown",
  "homepage": "https://github.com/beamly/q-combinators",
  "_id": "q-combinators@0.4.2",
  "dist": {
    "shasum": "5f6ede6d33b92f9d06f40c04e7d7f9fe581e781f"
  },
  "_from": "q-combinators@",
  "_resolved": "https://registry.npmjs.org/q-combinators/-/q-combinators-0.4.2.tgz"
}
